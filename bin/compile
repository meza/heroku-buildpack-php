#!/usr/bin/env bash
# bin/compile <build-dir> <cache-dir>

# fail fast
set -e
POSTFIX=201412101356
APACHE_VERSION=2.4.10-$POSTFIX
PHP_VERSION=5.5.14-$POSTFIX
VENDOR_VERSION=$POSTFIX

BASE_URL=https://meza.s3.amazonaws.com/heroku

APACHE_PATH="apache"
PHP_PATH="php"

BUILD_DIR=$1
CACHE_DIR=$2
LP_DIR=`cd $(dirname $0); cd ..; pwd`
env_dir=$3

protip "BUILD dir: $BUILD_DIR"
protip "Cache dir: $CACHE_DIR"
protip "LP dir: $LP_DIR"

# include .files when moving things around
shopt -s dotglob

export_env_dir() {
  env_dir=$1
  whitelist_regex=${2:-''}
  blacklist_regex=${3:-'^(PATH|GIT_DIR|CPATH|CPPATH|LD_PRELOAD|LIBRARY_PATH)$'}
  if [ -d "$env_dir" ]; then
for e in $(ls $env_dir); do
echo "$e" | grep -E "$whitelist_regex" | grep -qvE "$blacklist_regex" &&
      export "$e=$(cat $env_dir/$e)"
      :
    done
fi
}

protip() {
  echo
	echo "PRO TIP: $*"
}

# sed -l basically makes sed replace and buffer through stdin to stdout
# so you get updates while the command runs and dont wait for the end
# e.g. npm install | indent
indent() {
  c='s/^/ /'
  case $(uname) in
    Darwin) sed -l "$c";; # mac/bsd sed: -l buffers on line boundaries
    *) sed -u "$c";; # unix/gnu sed: -u unbuffered (arbitrary) chunks of data
  esac
}

  error() {
    echo " ! $*" >&2
    exit 1
  }

  status() {
    echo "-----> $*"
  }

cd $BUILD_DIR

# move app things to www
mkdir -p $CACHE_DIR/www
mv * $CACHE_DIR/www
mv $CACHE_DIR/www .

# keep Procfile
if [ -f www/Procfile ]; then
  mv www/Procfile .
fi

APACHE_URL="$BASE_URL/apache-$APACHE_VERSION.tar.gz"
echo "-----> Bundling Apache version $APACHE_VERSION"
curl --silent --max-time 60 --location "$APACHE_URL" | tar xz

mkdir -p $BUILD_DIR/apache/logs

VENDORS_URL="$BASE_URL/vendor-$VENDOR_VERSION.tar.gz"
echo "-----> Bundling vendors version $VENDOR_VERSION"
curl --silent --max-time 60 --location "$VENDORS_URL" | tar xz

PHP_URL="$BASE_URL/php-$PHP_VERSION.tar.gz"
echo "-----> Bundling PHP version $PHP_VERSION"
curl --silent --max-time 60 --location "$PHP_URL" | tar xz
chmod 755 $BUILD_DIR/php/lib/php/extensions/no-debug-non-zts-20121212/*.so


ls -la /app
ls -la /app/vendor
ls -la /app/vendor/node
ls -la /app/vendor/node/bin

# update config files
cp $LP_DIR/conf/httpd.conf $APACHE_PATH/conf
cp $LP_DIR/conf/php.ini php/lib

mkdir -p bin
ln -s $BUILD_DIR/php/bin/php bin/php
PATH=$PATH:$BUILD_DIR/php/bin

if [ -f www/package.json ]; then
	PATH=$PATH:$BUILD_DIR/vendor/node/bin

	cd $BUILD_DIR/www

	# If node_modules directory is checked into source control then
	# rebuild any native deps. Otherwise, restore from the build cache.

	if test -d $BUILD_DIR/www/node_modules; then
		echo "Found existing node_modules directory; skipping cache"
		echo "Rebuilding any native dependencies"
		npm rebuild 2>&1 | indent
	elif test -d $CACHE_DIR/node/node_modules; then
		echo "Restoring node_modules directory from cache"
		cp -r $CACHE_DIR/node/node_modules $BUILD_DIR/

		echo "Pruning cached dependencies not specified in package.json"
		npm prune 2>&1 | indent

		if test -f $CACHE_DIR/node/.heroku/node-version && [ $(cat $CACHE_DIR/node/.heroku/node-version) != "$node_version" ]; then
			echo "Node version changed since last build; rebuilding dependencies"
			npm rebuild 2>&1 | indent
	  fi

	fi

	# Handle npm's new cert bug
	# http://blog.npmjs.org/post/78085451721/npms-self-signed-certificate-is-no-more
	if [ ! -f "$BUILD_DIR/www/.npmrc" ]; then
	echo "Writing a custom .npmrc to circumvent npm bugs"
	  echo "ca=" > "$BUILD_DIR/www/.npmrc"
	fi

	# Scope config var availability only to `npm install`
	(
	  if [ -d "$env_dir" ]; then
	echo "Exporting config vars to environment"
		export_env_dir $env_dir
	  fi

	echo "Installing dependencies"
	  # Make npm output to STDOUT instead of its default STDERR
	  npm install --userconfig $BUILD_DIR/www/.npmrc --production 2>&1 | indent
	)
	npm install -g grunt-cli
	PATH=$PATH:$BUILD_DIR/www/node_modules/.bin
	grunt deploy --staging

	# Persist goodies like node-version in the slug
	mkdir -p $BUILD_DIR/.heroku

	# Save resolved node version in the slug for later reference
	echo $node_version > $BUILD_DIR/.heroku/node-version

	# Purge node-related cached content, being careful not to purge the top-level
	# cache, for the sake of heroku-buildpack-multi apps.
	rm -rf $CACHE_DIR/node_modules # (for apps still on the older caching strategy)
	rm -rf $CACHE_DIR/node
	mkdir -p $CACHE_DIR/node

	# If app has a node_modules directory, cache it.
	if test -d $BUILD_DIR/www/node_modules; then
	echo "Caching node_modules directory for future builds"
	  cp -r $BUILD_DIR/www/node_modules $CACHE_DIR/node
	fi

	# Copy goodies to the cache
	cp -r $BUILD_DIR/.heroku $CACHE_DIR/node

	echo "Cleaning up node-gyp and npm artifacts"
	rm -rf "$BUILD_DIR/www/.node-gyp"
	rm -rf "$BUILD_DIR/www/.npm"
fi
cd $BUILD_DIR

if [ -f www/composer.json ] && [ ! -d www/vendor ]; then
GIT_DIR_ORIG=$GIT_DIR
  unset GIT_DIR
  echo "-----> Installing Composer dependencies"
  COMPOSER_URL="http://getcomposer.org/composer.phar"
  curl --silent --max-time 60 --location "$COMPOSER_URL" > www/composer.phar
  cd www
  LD_LIBRARY_PATH=$BUILD_DIR/php/ext:$BUILD_DIR/vendor/pcre/lib $BUILD_DIR/php/bin/php -c $LP_DIR/conf/php.ini composer.phar install --prefer-source
  rm -rf vendor/**/.git
  cd $BUILD_DIR
  rm www/composer.phar
  export GIT_DIR=$GIT_DIR_ORIG
fi



cat >>boot.sh <<EOF
for var in \`env|cut -f1 -d=\`; do
  echo "PassEnv \$var" >> $BUILD_DIR/apache/conf/httpd.conf;
done
touch $BUILD_DIR/apache/logs/error_log
touch $BUILD_DIR/apache/logs/access_log
tail -F $BUILD_DIR/apache/logs/error_log &
tail -F $BUILD_DIR/apache/logs/access_log &
export LD_LIBRARY_PATH=$BUILD_DIR/php/lib/php
export PHP_INI_SCAN_DIR=$BUILD_DIR/www
echo "Launching apache"
exec $BUILD_DIR/apache/bin/httpd -DNO_DETACH
EOF

chmod +x boot.sh

cat >>Procfile <<EOF
web: sh boot.sh
EOF

# clean the cache
rm -rf $CACHE_DIR
